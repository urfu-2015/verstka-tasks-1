<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Яндекс.Почта и скорость загрузки</title>
</head>
<body>
<header>
    Блог компании Яндекс.Яндекс
</header>
<article>
    <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
    <div> Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
		какой он красивый, ни то, какой он удобный. Никому не понравится, когда 
		тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,
		иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
		и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</div>
		<h2>Что мы измеряем</h2>
		<h3>Этапы первой загрузки</h3>
			<div><ul>
				<li>подготовка;</li>
				<li>загрузка статики (HTTP-запрос и парсинг);</li>
				<li>исполнение модулей;</li>
				<li>инициализация базовых объектов;</li>
				<li>отрисовка.</li>
			</ul>
		<h3>Этапы отрисовки любой страницы</h3>
			<ul>
				<li>подготовка к запросу на сервер;</li>
				<li>запрос данных с сервера;</li>
				<li>шаблонизация</li>
				<li>обновление DOM.</li>
			</ul>
	</div>
	<div><q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы
		<q>Что же дальше?</q> - вопрошаете вы
		<q>А давай построим график!</q> - отвечаем мы
		<q>А что будем считать?</q> - уточняете вы</div>
	<div>
		<div> Как вы знаете, медиана – это серединное, а не среднее значение в выборке.
			Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
			В общем случае медиана отлично показывает, сколько грузится средний пользователь.</div>
		<div> В случае ускорения или замедления медиана, конечно, изменится. Но она не может
			рассказать, сколько пользователей ускорилось, а сколько замедлилось.</div>
		<div> <abbr title="Application Performance Index">APDEX</abbr> – метрика, которая сразу говорит: хорошо или плохо. Метрика
			работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
			время показа страницы попало в него, то пользователь счастлив. Берем еще один
			интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
			показана за это время, то пользователь в целом удовлетворен скоростью работы,
			но уже не настолько счастлив. И применяем формулу:</div>
		<div> (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
			Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
			хорошо или плохо работает почта.</div>
	</div>
	<h2>Как мы измеряем</h2>
	<div>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
		причину замедления: медленнее стал отвечать сервер либо слишком долго
		выполняется JavaScript. Выглядит это примерно так:
		<code>this.timings['look-ma-im-start'] = Date.now();
			this.timings['look-ma-finish'] = Date.now();</code>
			C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
			отправке рассчитываются. На этапах разница между “end” и “start” не считается,
			а все вычисления производятся в конце:
		<code> var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
		И на сервер прилетают подобные записи:
		<code>serverResponse=50&domUpdate=60</code></div>
	<h2>Как мы ускоряем</h2>
	<div>Чтобы снизить время загрузки почты при выходе новых версий,
		мы уже делаем следующее:
		<ul>
			<li>включаем gzip;</li>
			<li>выставляем заголовки кэширования;</li>
			<li>фризим CSS, JS, шаблоны и картинки;</li>
			<li>используем CDN;</li>
		</ul>
		<div>Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой
		передавать только diff между ней и той, которая сохранена у пользователя?»
		В браузере же останется просто наложить патч на клиенте.</div>
		<div>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,
		RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
		не получили должного распространения в браузерах и на серверах.</div>
		<div>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,
		начали искать реализации diff на JS. На популярных хостингах кода нашли
		библиотеки:
		<ul>
			<li>VCDiff</li>
			<li>google-diff-patch-match</li>
		</ul></div>
		<div>Для окончательного выбора библиотеки нам нужно сравнить:
			<table>
				<thead>
					<tr>
						<th>Библиотека</th>
						<th>IE 9</th>
						<th>Opera 12</th>
					</tr>
				<tbody>
					<tr>
						<th>vcdiff</th>
						<th>8</th>
						<th>5</th>
					</tr>
					<tr>
						<th>google diff</th>
						<th>1363</th>
						<th>76</th>
					</tr>
				</tbody>
				</thead>
			</table></div>
		<div>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
			где и как хранить статику на клиенте.</div>
			<div>Формат файла с патчами для проекта выглядит так:
				<code>[
					{<br>
						"k": "jane.css",<br>
						"p": [patch],<br>
						"s": 4554<br>
					},<br>
					{<br>
						"k": "jane.css",<br>
						"p": [patch],<br>
						"s": 4554<br>
					}<br>
					]</code></div>
		<div>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
			каждого объекта есть три свойства. k — названия ключа в localStorage для этого
			ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для
			ресурса актуальной версии, чтобы потом можно было проверить правильность
			наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</div>
		<div><dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dfn>
			— итерационный метод численной оптимизации, предназначенный для
			нахождения локального максимума/минимума нелинейного функционала
			без ограничений.</div>
		<div>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
			<ul>
				<li><dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки
				целостности данных</li>
				<li><dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
					или дайджестов сообщения произвольной длины и последующей проверки
					их подлинности.</li>
			Потому что он быстрый, компактный и легок в реализации.</div>
	</div></div></div>
	<h2>Итог</h2>
	<div>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:
		<table>
			<thead>
				<tr>
					<th>Релиз</th>
					<th>С патчем</th>
					<th>Без патча</th>
				</tr>
			<tbody>
				<tr>
					<th>7.7.20</th>
					<th>397</th>
					<th>174 549</th>
				</tr>
				<tr>
					<th>7.7.21</th>
					<th>383</th>
					<th>53 995</th>
				</tr>
				<tr>
					<th>7.7.22</th>
					<th>483</th>
					<th>3 995</th>
				</tr>
			</tbody>
			<thead>
		</table>
		</div>
	<div><dt>Автор:</dt> <dd>@doochik</dd>
		С++ разработик
		<dt>Электронная почта:</dt> <dd>(doochik@yandex-team.ru)</dd>
		<dt>Компания:</dt> <dd>Яндекс</dd></div>
	<div>Комментарии (3):
		<p>Mogaika (mogaika@yandex-team.ru) <time>30 ноября 2014 в 17:05</time></p>
		<p> А можете привести сравнение, на сколько быстрее грузится lite версия?</p>
		<p> JIguse (mrawesome@yandex.ru)<time> 29 ноября 2014 в 21:30</time></p>
		<p> Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
			подробностями о внутренней работе сервисов.</p>
		<p> Brister (brist89@yandex-team.ru)<time> 24 ноября 2014 в 13:13</time></p>
		<p><q>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
			Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
			хорошо или плохо работает почта.</q></p>
		<p>наверное все-таки от 0.5 до 1</li></p>
		<p>alexeimois (test@yandex.ru) <time>22 ноября 2014 в 17:35</time></p>
		<p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:</p>
		<a href=help.yandex.ru/metrika/reports/monitoring_timing.xml>help.yandex.ru/metrika/reports/monitoring_timing.xml</a></div>
</article>
<footer>
	<div> © Яндекс, <a href=mailto:help@yandex.ru></a>help@yandex.ru, Хохрякова, 10 </div>
</footer>
</body>
