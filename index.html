</html>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
</head>
<body>
<font face="Arial">
<p>Блог компании Яндекс.</p>
<p>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</p>
<p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br />
    какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br />
    тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br />
    иногда &mdash; исправляем ошибки, а это значит, у нас постоянно появляются новый код<br />
    и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</p>
<p>Что мы измеряем</p>
<p>Этапы первой загрузки:<br />
    * подготовка;<br />
    * загрузка статики (HTTP-запрос и парсинг);<br />
    * исполнение модулей;<br />* инициализация базовых объектов;<br />
    * отрисовка.</p>
<p>Этапы отрисовки любой страницы:<br />
    * подготовка к запросу на сервер;<br />
    * запрос данных с сервера;<br />
    * шаблонизация;<br />
    * обновление DOM.</p>
<p>- &laquo;Ок, теперь у нас есть метрики, мы можем отправить их на сервер&raquo; - говорим мы<br />
    - &laquo;Что же дальше?&raquo; - вопрошаете вы<br />
    - &laquo;А давай построим график!&raquo; - отвечаем мы<br />
    - &laquo;А что будем считать?&raquo; - уточняете вы</p>
<p>Как вы знаете, медиана &ndash; это серединное, а не среднее значение в выборке.<br />
    Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана &ndash; 3, а среднее &ndash; 6,5.<br />
    В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>
<p>В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br/>
    рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>
<p>APDEX &ndash; метрика, которая сразу говорит: хорошо или плохо. Метрика<br />
    работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br />
    время показа страницы попало в него, то пользователь счастлив. Берем еще один<br />
    интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br />
    показана за это время, то пользователь в целом удовлетворен скоростью работы,<br />
    но уже не настолько счастлив. И применяем формулу:</p>
<p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br />
    Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br />
    хорошо или плохо работает почта.</p>
<p>Как мы измеряем</p>
<p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br />
    причину замедления: медленнее стал отвечать сервер либо слишком долго<br />
    выполняется JavaScript. Выглядит это примерно так:</p>
<p><code>this.timings['look-ma-im-start'] = Date.now();</code><br />
    <code>this.timings['look-ma-finish'] = Date.now();</code></p>
<p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br />
    отправке рассчитываются. На этапах разница между &ldquo;end&rdquo; и &ldquo;start&rdquo; не считается,<br />
    а все вычисления производятся в конце:</p>
<p>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</p>
<p>И на сервер прилетают подобные записи:</p>
<p>serverResponse=50&amp;domUpdate=60</p>
<p>Как мы ускоряем</p>
<p>Чтобы снизить время загрузки почты при выходе новых версий, <br />мы уже делаем следующее:</p>
<p>* включаем gzip;<br />
    * выставляем заголовки кэширования;<br />
    * фризим CSS, JS, шаблоны и картинки;<br />
    * используем CDN;</p>
<p>Мы подумали: &laquo;А что если хранить где-то старую версию файлов, а при выходе новой<br/>
    передавать только diff между ней и той, которая сохранена у пользователя?&raquo;<br />
    В браузере же останется просто наложить патч на клиенте.</p>
<p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP &mdash; например,<br />
    RFC 3229 &laquo;Delta encoding in HTTP&raquo; и &laquo;Google SDHC&raquo;, &mdash; но по разным причинам они<br />
    не получили должного распространения в браузерах и на серверах.</p>
<p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br />
    начали искать реализации diff на JS. На популярных хостингах кода нашли<br />
    библиотеки:<br />
    - VCDiff<br />
    - google-diff-patch-match</p>
<p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
<p><pre>
Библиотека  | IE  9  | Opera 12</pre>
<pre>----------  | ----   | --------</pre>
<pre>vcdiff      | 8      | 5</pre>
<pre>google diff | 1363   | 76</pre>
<p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br />где и как хранить статику на клиенте.</p>
<p>Формат файла с патчами для проекта выглядит так:<br />
    [  <br />
    {  <br />
    "k": "jane.css",  <br />
    "p": [patch],  <br />
    "s": 4554  <br />
    },  <br />
    {  <br />
    "k": "jane.css",  <br />
    "p": [patch],  <br />
    "s": 4554  <br />
    }  <br />
    ]</p>
<p>То есть это обычный массив из объектов. Каждый объект &mdash; отдельный ресурс. У  <br/>
    каждого объекта есть три свойства. k &mdash; названия ключа в localStorage для этого  <br />
    ресурса. p &mdash; патч для ресурса, который сгенерировал vcdiff. s &mdash; чексумма для<br/>
    ресурса актуальной версии, чтобы потом можно было проверить правильность  <br />
    наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</p>
<a href="https://camo.githubusercontent.com/87655e52351caf112734f0d172ed084113d43a96/68747470733a2f2f696d672d666f746b692e79616e6465782e72752f6765742f31353438372f33323136373634382e302f305f3133333437665f33343966363138615f58354c" target="_blank">
    <img src="https://camo.githubusercontent.com/87655e52351caf112734f0d172ed084113d43a96/68747470733a2f2f696d672d666f746b692e79616e6465782e72752f6765742f31353438372f33323136373634382e302f305f3133333437665f33343966363138615f58354c" width="400"
         style="max-width:100%;"></a>
<p>Алгоритм Бройдена &mdash; Флетчера &mdash; Гольдфарба &mdash; Шанно (BFGS)  <br />
    &mdash; итерационный метод численной оптимизации, предназначенный для  <br />
    нахождения локального максимума/минимума нелинейного функционала  <br />
    без ограничений.</p>
<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:  <br />
    CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки  <br />
    целостности данных <br />
    md5 - 128-битный алгоритм хеширования. Предназначен для создания &laquo;отпечатков&raquo;<br/>
    или дайджестов сообщения произвольной длины и последующей проверки  <br />
    их подлинности.</p>
<p>Потому что он быстрый, компактный и легок в реализации.</p>
<p>Итог</p>
<p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
<p><pre> Релиз | С патчем | Без патча
  <br />7.7.20 | 397      | 174 549
  <br />7.7.21 | 383      | 53 995
  <br />7.7.22 | 483      | 3 995</pre> </p>
<p>Автор: @doochik  <br />
    С++ разработик  <br />
    Электронная почта: (doochik@yandex-team.ru)  <br />
    Компания: Яндекс</p>
<p>Комментарии (3):</p>
<p>- Mogaika (mogaika@yandex-team.ru) 30 ноября 2014 в 17:05</p>
<p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p>
<p>- JIguse (mrawesome@yandex.ru) 29 ноября 2014 в 21:30</p>
<p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми  <br />
    подробностями о внутренней работе сервисов.</p>
<p>- Brister (brist89@yandex-team.ru) 24 ноября 2014 в 13:13</p>
<p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).  <br />
    Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,  <br />
    хорошо или плохо работает почта.</p>
<p>наверное все-таки от 0.5 до 1</p>
<p>- alexeimois (test@yandex.ru) 22 ноября 2014 в 17:35</p>
<p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:  <br />
    help.yandex.ru/metrika/reports/monitoring_timing.xml</p>
<p>&copy; Яндекс, help@yandex.ru, Хохрякова, 10.</p>
</font>
</body>
</html>