<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Яндекс.Блог</title>
    </head>
    <body>
        <style>
            li {
                list-style: none;
            }
            li:before {
                content: "*";
            }
            ul {
                padding: 0; 
                margin-left: 0px;
            }
            ul.dashed {
                list-style: none;
            }
            ul.dashed > li:before {
                content: "-";
                width: 1em;
            }
            table {
                text-align: left;
                width: 300px;
                padding-right: 5px;
            }
            tr > td.borderRight {
                border-right: 1px solid black;
            } 
        </style>

        <div>Блог компании Яндекс.</div>
        <p>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</p>
         <p>
                Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
                какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
                тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
                иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
                и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
         </p>
        <p>
                Что мы измеряем
        </p>
        <ul>
            <lh>Этапы первой загрузки:</lh>
            <li>подготовка;</li>
            <li>загрузка статики (HTTP-запрос и парсинг);</li>
            <li>исполнение модулей;</li> 
            <li>инициализация базовых объектов;</li>
            <li>отрисовка.</li>
         </ul>
        <ul>
           <lh>Этапы отрисовки любой страницы:</lh>
           <li>подготовка;</li>
           <li>загрузка статики (HTTP-запрос и парсинг);</li>
           <li>исполнение модулей;</li> 
           <li>инициализация базовых объектов;</li>
           <li>отрисовка.</li>
        </ul>
        <ul class="dashed">
            <li> &laquo;Ок, теперь у нас есть метрики, мы можем отправить их на сервер&raquo; &ndash; говорим мы</li>
            <li> &laquo;Что же дальше?&raquo; &ndash; вопрошаете вы</li>  
            <li> &laquo;А давай построим график!&raquo; &ndash; отвечаем мы</li>  
            <li> &laquo;А что будем считать?&raquo; &ndash; уточняете вы</li>  
        </ul>

        <p>
            Как вы знаете, медиана &ndash; это серединное, а не среднее значение в выборке.<br>
            Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана &ndash; 3, а среднее &ndash; 6,5.<br>
            В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br>
        </p>
        <p>
            В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
            рассказать, сколько пользователей ускорилось, а сколько замедлилось.
        </p>
        <p>
            APDEX &ndash; метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
            работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br>
            время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
            интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
            показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
            но уже не настолько счастлив. И применяем формулу:
        </p>
        <p>
            (кол-во счастливых пользователей &plus; кол-во удовлетворенных &frasl; 2) &frasl; (кол-во всех).<br>
            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
            хорошо или плохо работает почта.
        </p>
        <p>Как мы измеряем</p>
        <p>
            Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
            причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
            выполняется JavaScript. Выглядит это примерно так:
        </p>
        <p>
            <code>
                this.timings['look-ma-im-start'] = Date.now();
                this.timings['look-ma-finish'] = Date.now();
            </code>
        </p>
        <p>
            C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br>
            отправке рассчитываются. На этапах разница между &#8220;end&#8221; и &#8220;start&#8221; не считается,<br>
            а все вычисления производятся в конце:
        </p>
        <p>
            <code>
                var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
            </code>
        </p>
        <p>И на сервер прилетают подобные записи:</p>
        <p>serverResponse=50&domUpdate=60</p>
        <p>Как мы ускоряем</p>
        <p>
            Чтобы снизить время загрузки почты при выходе новых версий,<br>
            мы уже делаем следующее:
        </p>
        <ul>
            <li>включаем gzip;</li>
            <li>выставляем заголовки кэширования;</li>
            <li>фризим CSS, JS, шаблоны и картинки;</li>
            <li>используем CDN;</li>
        </ul>
        <p>
            Мы подумали: &laquo;А что если хранить где-то старую версию файлов, а при выходе новой<br> 
            передавать только diff между ней и той, которая сохранена у пользователя?&raquo;<br>
            В браузере же останется просто наложить патч на клиенте.
        </p>
        <p>
            На самом деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
            RFC 3229 &laquo;Delta encoding in HTTP&raquo; и &laquo;Google SDHC&raquo;, &ndash; но по разным причинам они<br>
            не получили должного распространения в браузерах и на серверах.
        </p>
        <p>
            <ul class="dashed">
                <lh>
                    Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
                    начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
                    библиотеки:
                </lh>
                <li>VCDiff</li>
                <li>google&ndash;diff&ndash;patch&ndash;match</li>
            </ul>
        </p>
        <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
        <table>
            <tr>
                <td class="borderRight">Библиотека</td>
                <td class="borderRight">IE 9</td>
                <td>Opera 12</td>
            </tr>
            <tr>
                <td class="borderRight">----------</td>
                <td class="borderRight">----</td>
                <td>--------</td>
            </tr>
            <tr>
                <td class="borderRight">vcdiff</td>
                <td class="borderRight">8</td>
                <td>5</td>
            </tr>
            <tr>
                <td class="borderRight">google diff</td>
                <td class="borderRight">1363</td>
                <td>76</td>
            </tr>
        </table>
        <p>
            Формат файла с патчами для проекта выглядит так:<br>
            <pre>     
                [
                    {
                        "k": "jane.css",
                        "p": [patch],
                        "s": 4554
                    },
                    {
                        "k": "jane.css",
                        "p": [patch],
                        "s": 4554
                    }
                ]
        </pre>
        <p>
            То есть это обычный массив из объектов. Каждый объект &ndash; отдельный ресурс. У<br>
            каждого объекта есть три свойства. k &ndash; названия ключа в localStorage для этого<br>
            ресурса. p &ndash; патч для ресурса, который сгенерировал vcdiff. s &ndash; чексумма для<br>
            ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
            наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
        </p>
        <p>
            Дано &epsilon;, <dfn>x<sub>0</sub></dfn><br>
            инициализировать <dfn>H<sub>0</sub></dfn><br>
            <dfn>k</dfn> = 0<br>
            <b>while</b> &Iota;&Iota;&nabla;&fnof;<sub><dfn>k</dfn></sub>&Iota;&Iota; &gt; &epsilon;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;найти направление <dfn>p<sub>k</sub></dfn> = &minus;<dfn>C<sub>k</sub>&nabla;&fnof;<sub><dfn>k
            </dfn></sub></dfn><br>
            &nbsp;&nbsp;&nbsp;&nbsp;вычислить <dfn>x<sub>k+1</sub> = x<sub>k</sub> &plus; &alpha;<sub>k</sub>p<sub>k</sub>, 
             &alpha;<sub>k</sub></dfn> удовлетворяет условиям Вольфе<br>
             &nbsp;&nbsp;&nbsp;&nbsp;обозначить <dfn>s<sub>k</sub> = x<sub>k+1</sub> &minus; x<sub>k</sub> и y<sub>k</sub> = &nabla;&fnof;<sub>k+1</sub>
                &minus; &nabla;<sub>k</sub></dfn><br>
                &nbsp;&nbsp;&nbsp;&nbsp;вычислить <dfn>C<sub>k+1</sub></dfn><br>
                &nbsp;&nbsp;&nbsp;&nbsp;<dfn>k = k &plus;</dfn><br>
            <b>end</b>
        </p>
        <p>
            Алгоритм Бройдена &ndash; Флетчера &ndash; Гольдфарба &ndash; Шанно (BFGS)<br>
            &ndash; итерационный метод численной оптимизации, предназначенный для<br>
            нахождения локального максимума/минимума нелинейного функционала<br>
            без ограничений.
        </p>
        <p>
            Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
            CRC16&frasl;32 - алгоритм нахождения контрольной суммы, предназначенный для проверки<br>
            целостности данных<br>
            md5 &ndash; 128&ndash;битный алгоритм хеширования. Предназначен для создания &laquo;отпечатков&raquo;<br>
            или дайджестов сообщения произвольной длины и последующей проверки<br>
            их подлинности.
        </p>
        <p>
            Потому что он быстрый, компактный и легок в реализации.
        </p>
        <p>Итог</p>
        <p>
            Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:
        </p>
        <table>
            <tr>
                <td class="borderRight">Релиз</td>
                <td class="borderRight">С патчем</td>
                <td>Без патча</td>
            </tr>
            <tr>
                <td class="borderRight">7.7.20</td>
                <td class="borderRight">397</td>
                <td>174 549</td>
            </tr>
            <tr>
                <td class="borderRight">7.7.21</td>
                <td class="borderRight">383</td>
                <td>53 995</td>
            </tr>
            <tr>
                <td class="borderRight">7.7.22</td>
                <td class="borderRight">483</td>
                <td>3 995</td>
            </tr>
        </table>
        <p>
            Автор: &#64;doochik<br>
            С++ разработик<br>
            Электронная почта: (doochik&#64;yandex&ndash;team.ru)<br>
            Компания: Яндекс
        </p>
        <ul class="dashed">
            <lh>Комментарии (3):</lh>
            <li>
                    Mogaika (mogaika&#64;yandex&ndash;team.ru) 30 ноября 2014 в 17:05<br>
                    <p></p>
                    А можете привести сравнение, на сколько быстрее грузится lite версия?
            </li>
            <p></p>
            <li> 
                    JIguse (mrawesome&#64;yandex.ru) 29 ноября 2014 в 21:30<br>
                    <p></p>
                    Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
                    подробностями о внутренней работе сервисов.
            </li>
            <p></p>
            <li>
                    Brister (brist89&#64;yandex&ndash;team.ru) 24 ноября 2014 в 13:13<br>
                    <p></p>
                    (кол-во счастливых пользователей &plus; кол-во удовлетворенных &frasl; 2) &frasl; (кол-во всех).<br>
                    Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                    хорошо или плохо работает почта.
            </li>
            <p>наверное все&ndash;таки от 0.5 до 1</p>
            <li>
                    alexeimois (test&#64;yandex.ru) 22 ноября 2014 в 17:35<br>
                    <p></p>
                    Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
                    help.yandex.ru&frasl;metrika&frasl;reports&frasl;monitoring&#95;timing.xml
            </li>
        </ul>
        <p>
            &copy; Яндекс, help&#64;yandex.ru, Хохрякова, 10
        </p>
    </body>
</html>
