<html>
<head>
<meta charset="UTF-8">
<meta name="andrej.veshinin" content="Domashka1">
<title>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</title>
</head>	
<header>
	<nav>		 
		<a href="#1">Что мы измеряем</a>
		<a href="#2">Как мы измеряем</a>
		<a href="#3">Как мы ускоряем</a>
		<a href="#4">Алгоритм Бройдена Флетчера(BFGS)</a>			
		<a href="#5">Коментарии</a>
	</nav>		 
<h2>Яндекс.почта: как мы измеряем скорость загрузки и улучшаем её<h2> 
</header>
<div class="tab" style="border-radius:40px 10px;">
	Если ваш сайт медленно грузится,
	вы рискуете тем, что люди не оценят ни то,
	какой он красивый, ни то, какой он удобный.<br>
	Никому не понравится, когда все тормозит. 
	Мы регулярно добавляем в Яндекс.
	Почту новую функциональность,<br> иногда — исправляем ошибки, 
	а это значит, у нас постоянно появляются новый код
	и новая логика.<br> Всё это напрямую влияет на скорость работы интерфейса.
</div>
<hr>
<a name="1"><h2><u>Что мы измеряем</u></h2></a> <!-- Чтоы слово было подчеркнуто. Элемент U."-->
<i><h3>Этапы первой загрузки:</h3></i>
	<ul><b>
		<li>Подготовка;</li>
		<li>загрузка статики (HTTP-запрос и парсинг);</li>
		<li>исполнение модулей;</li>
		<li>инициализация базовых объектов;</li>
		<li>Отрисовка.</li>  	
	</b></ul>
<section>
<article>
	<h2><u>Этапы отрисовки любой страницы:</u></h2>
	  <ul><b>
         <li>подготовка к запросу на сервер;</li>
	     <li>запрос данных с сервера;</li>
	     <li>шаблонизация;</li>
	     <li>обновление DOM.</li>
         </ul>
<div>
	-«Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы
	— «Что же дальше?» - вопрошаете вы
	— «А давай построим график!» - отвечаем мы
	— «А что будем считать?» - уточняете вы		 
</div> 

<div> 
	Как вы знаете,<mark> медиана – это серединное
	</mark>, а не среднее значение в выборке.
	Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
	В общем случае медиана отлично показывает, сколько грузится средний пользователь.
	В случае ускорения или замедления медиана, конечно, изменится. Но она не может
	рассказать, сколько пользователей ускорилось, а сколько замедлилось.
	APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика
	работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
	время показа страницы попало в него, то пользователь счастлив. Берем еще один
	интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
	показана за это время, то пользователь в целом удовлетворен скоростью работы,
	но уже не настолько счастлив. И применяем формулу:
	<mark>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех)</mark>.
	Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
	хорошо или плохо работает почта.</p>		
</div>
<hgroup>
<a name="2"><h1>Как мы измеряем</h1></a>
<h2>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
	причину замедления: медленнее стал отвечать сервер либо слишком долго
	выполняется JavaScript.</h2></hgroup>
<figure>
<figcaption>Выглядит это примерно так:</figcaption>
	<pre><code>
		this.timings['look-ma-im-start'] = Date.now();
		this.timings['look-ma-finish'] = Date.now();
		</code>
	</pre>		   
</figure>
<p></p>
<p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
отправке рассчитываются. </p>
<figure>
<figcaption>На этапах разница между “end” и “start” не считается,
			а все вычисления производятся в конце:</figcaption>
<pre><code>
	var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
</pre>
<figcaption>И на сервер прилетают подобные записи:</figcaption>
<pre><code>serverResponse=50&domUpdate=60</code>
</pre>
</figure>
<hr>
<hgroup>
<a name="3"><h2>Как мы ускоряем</h2></a>
<h3>Чтобы снизить время загрузки почты при выходе новых версий,
мы уже делаем следующее:</h3>
	<b><ul>
		<li>включаем gzip;</li>
		<li>выставляем заголовки кэширования;</li>
		<li>фризим CSS, JS, шаблоны и картинки;</li>
		<li>используем CDN;</li>
	</ul></b>
</hgroup>
<p>Мы подумали: <blockquote>«А что если хранить где-то старую версию файлов, а при выходе новой
передавать только <mark>diff</mark> между ней и той, которая сохранена у пользователя?»</blockquote>
В браузере же останется просто наложить патч на клиенте.
На самое деле эта идея не новая.<br> Уже существуют стандарты для HTTP — например,
RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
не получили должного распространения в браузерах и на серверах.
Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,
начали искать реализации diff на JS. На популярных хостингах кода нашли
библиотеки:</p>
<b><ul>
	<li>VCDiff;</li>
	<li>google-diff-patch-match.</li>	
</b></ul>
<h4>Для окончательного выбора библиотеки нам нужно сравнить:</h4>
<table border="1" bgcolor="white" height="100" width="250">
	<thead>
		<tr>
			<th>Библиотека</th>
			<th>IE 9 </th>
			<th>Opera 12</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>vcdiff</td>
			<td>8</td>
			<td>5</td>
		</tr>   
		<tr>
			<td>google diff</td>
			<td>1363</td>
			<td>76</td>		
		</tr>
	</tbody>
</table>
<h5>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
	где и как хранить статику на клиенте.</h5>
<figure>
	<figcaption>Формат файла с патчами для проекта выглядит так:</figcaption>
		<pre><code>
				{
					"k": "jane.css",
					"p": [patch],
					"s": 4554
				},
				{
					"k": "jane.css",
					"p": [patch],
					"s": 4554
				}
		</code></pre>
</figure>
<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
	каждого объекта есть три свойства: <blockquote>k — названия ключа в <code>localStorage</code> 
	для этого ресурса.</blockquote> <blockquote>p — патч для ресурса, который сгенерировал vcdiff.
	</blockquote> <blockquote>s — чексумма для ресурса актуальной версии, чтобы потом можно было проверить 
	правильность наложения патча на клиенте.</blockquote>
</p>
<h5><u>Чексумма</u> вычисляется по алгоритму Флетчера.</h5>
<a name="4"><dl>
		<dt>Алгоритм Бройдена Флетчера(BFGS)</dt>
		<i><dd>итерационный метод численной оптимизации, предназначенный для
нахождения локального максимума/минимума нелинейного функционала
без ограничений.
		</dd></i>
</dl></a>
<u><p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p></u>
<dl>
<strong>
	<dt>CRC16/32 -</dt>
</strong>
		<i><dd>алгоритм нахождения контрольной суммы, предназначенный для проверки
			   целостности данных.</dd></i>
<strong>
		<dt>md5 -</dt></strong>
        <i><dd>128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
				или дайджестов сообщения произвольной длины и последующей проверки
				их подлинности.</dd></i>
</dl>  
<h5>Потому что он быстрый, компактный и легок в реализации!!!</h5>
<hr>
<hgroup>
	<h5>Итог.</h5>
	<h6>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</h6>
</hgroup>
<table border="1" bgcolor="white" height="100" width="250" >
	   <thead>
	      <tr>
		     <th>Релиз</th>
			 <th>С патчем</th>
			 <th>Без патча</th>
		  </tr>
	   </thead>
	      <tr>
	         <td>7.7.20</td>
			 <td>397</td>
			 <td>174 549</td>
		  </tr>
		  <tr>
		     <td>7.7.21</td>
			 <td>383</td>
			 <td>53 995</td>
		  </tr>
		  <tr>
		      <td>7.7.22</td>
			  <td>483</td>
			  <td>3 995</td>
		  </tr>
	</table>
<hr>
<footer>
<p>Автор: <strong>@doochik</strong>С++ разработчик
<address>Электронная почта:<a href="mailto:doochik@yandex-team.ru"> (doochik@yandex-team.ru)</a></address>
</p>
<p>Компания: Яндекс</p>
</footer>
<a name="5"><p>Коментарии(3):</p></a>
<section>
<article>
	- Mogaika <a href="mailto:mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a>30 ноября 2014 в 17:05
	А можете привести сравнение, на сколько быстрее грузится lite версия?
</article>
<article>
	- JIguse <a href="mailto:mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> 29 ноября 2014 в 21:30
	 Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
	подробностями о внутренней работе сервисов.
</article>
<article>
	- Brister <a href="mailto:brist89@yandex-team.ru">(brist89@yandex-team.ru)</a> 24 ноября 2014 в 13:13
	(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
	 Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
	хорошо или плохо работает почта.наверное все-таки от 0.5 до 1
</article>
<article>
	- alexeimois <a href="mailto:test@yandex.ru">(test@yandex.ru)</a> 22 ноября 2014 в 17:35
	 Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
	 help.yandex.ru/metrika/reports/monitoring_timing.xml
</article>
</section>
<p></p>
<hr>
<footer>
<p>© Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</p>
</footer>
</body>
</head>
</html>