<!DOCTYPE html>
<html>
<!-- Ваш замечательный код -->

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Яндекс, почта, скорость, загрузка, ускорять">
    <meta name="author" content="doochik">
    <base target="_blank">
    <title>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ / Блог компании Яндекс.</title>
    <style>
        blockquote
        {
            background: #f7f7f7;
            width: 1000px;  
        }
        
        .author-info
        {
            background: #e2ecf6;
            padding: 10px;
            margin: 5px;
        }
        
        .untagged-list
        {
            list-style: none;
        }
        
        .comment-info
        {
            background: #e2ecf6;
            padding: 10px;
            margin: 5px;
        }
    </style>
</head>

<body>
    <header>
        <h1>Блог компании Яндекс.</h1>
    </header>

    <article>
        <main>
            <hgroup>
                <h2>ЯНДЕКС.ПОЧТА:</h2>
                <h3>КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h3>
            </hgroup>

            <p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то, какой он красивый, 
            ни то, какой он удобный. Никому не понравится, когда все тормозит. 
            Мы <em>регулярно</em> добавляем в Яндекс.Почту 
            новую функциональность, иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код 
            и новая логика.
            Всё это напрямую влияет на скорость работы интерфейса.
            </p>
            <hr>
            <h5>Что мы измеряем</h5>

            <p>Этапы первой загрузки:</p>
            <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
            </ul>

            <p>Этапы отрисовки любой страницы:</p>
            <ul>
                <li>подготовка к запросу на сервер;</li>
                <li>запрос данных с сервера;</li>
                <li>шаблонизация;</li>
                <li>обновление DOM.</li>
            </ul>

            <p>&mdash;"Ок, теперь у нас есть метрики, мы можем отправить их на сервер"&ndash; говорим мы
                <br>&mdash;"Что же дальше?"&ndash; вопрошаете вы
                <br>&mdash;"А давай построим график!"&ndash; отвечаем мы
                <br>&mdash;"А что будем считать?"&ndash; уточняете вы</p>

            <p>Как вы знаете, <dfn>медиана</dfn> – это серединное, а не среднее значение в выборке. 
            Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5. 
            В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>

            <p>В случае ускорения или замедления медиана, конечно, изменится. 
            Но она не может рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>

            <p><abbr title="Application Performance Index">APDEX</abbr> – метрика, которая сразу говорит:
                хорошо или плохо. Метрика работает очень просто. Мы выбираем временной интервал [0; t],
                такой, что если время показа страницы попало в него, то пользователь счастлив. 
                Берем еще один интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
                показана за это время, то пользователь в целом удовлетворен скоростью работы, 
                но уже не настолько счастлив. И применяем формулу:</p>

            <blockquote>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).</blockquote>
            <p>Получается значение от нуля до единицы, которое, видимо, лучше всего показывает, хорошо или 
            плохо работает почта.</p>

            <h5>Как мы измеряем</h5>

            <p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять причину замедления:
            медленнее стал отвечать сервер либо слишком долго выполняется JavaScript. Выглядит это примерно так:</p>
            <code>
                    this.timings['look-ma-im-start'] = Date.now(); this.timings['look-ma-finish'] = Date.now();
            </code>

            <p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и
            при отправке рассчитываются. На этапах разница между “end” и “start” не считается,
            а все вычисления производятся в конце:</p>
            <code>
               var <var>totalTime</var>= this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
            </code>
            <br><p>И на сервер прилетают подобные записи:</p>
            <samp>serverResponse=50&amp;domUpdate=60</samp>

            <h5>Как мы ускоряем</h5>

            <p>Чтобы снизить время загрузки почты при выходе новых версий, мы уже делаем следующее:</p>
            <ul>
                <li>включаем gzip;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>фризим <abbr title="Cascading Style Sheets">CSS</abbr>, <abbr title="JavaScript">JS</abbr>,
                шаблоны и картинки;</li>
                <li>используем <abbr title="Content Delivery Network">CDN</abbr>;</li>
            </ul>

            <p>Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой передавать 
            только diff между ней и той, которая сохранена у пользователя?» В браузере же останется просто 
            наложить патч на клиенте.</p>

            <p>На самое деле эта идея не нова. Уже существуют стандарты для 
            <abbr title="HyperText Transfer Protocol">HTTP</abbr> — например, RFC 3229 «Delta encoding in HTTP» 
            и «Google SDHC», — но по разным причинам они не получили должного распространения в браузерах 
            и на серверах.</p>

            <p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления, начали искать 
            реализации diff на JS. На популярных хостингах кода нашли библиотеки:
            </p>
            <ul class="untagged-list">
                <li>- VCDiff</li>
                <li>- google-diff-patch-match</li>
            </ul>
            <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>

            <table>
                <thead>
                    <tr>
                        <th>Библиотека</th>
                        <th>IE 9</th>
                        <th>Opera 12</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>vcdiff</td>
                        <td>8</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>google diff</td>
                        <td>1363</td>
                        <td>76</td>
                    </tr>
                </tbody>
            </table>

            <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем, где и как хранить
            статику на клиенте.</p>

            <figure>
                <figcaption>Формат файла с патчами для проекта выглядит так:</figcaption>
                <pre>
 [
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]                   
                </pre>
            </figure>

            <p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. 
            У каждого объекта есть три свойства. <dfn>k</dfn> — названия ключа в localStorage для этого ресурса.
            <dfn>p</dfn> — патч для ресурса, который сгенерировал vcdiff. 
            <dfn>s</dfn> — чексумма для ресурса актуальной версии, 
            чтобы потом можно было проверить правильность наложения патча на клиенте.
            Чексумма вычисляется по алгоритму Флетчера.</p>

            <dl>
                <dt>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dt>
                <dd>— итерационный метод численной оптимизации, 
                предназначенный для нахождения локального максимума/минимума нелинейного функционала 
                без ограничений.</dd>
            </dl>
            
            <blockquote>
                дано &epsilon;, x<sub>0</sub><br>
                инициализировать H<sub>0</sub><br>
                k = 0<br>
                
                <pre>while ||&nabla;&fnof;<sub>k</sub>||&gt;&epsilon;
    найти направление p<sub>k</sub> = -C<sub>k</sub>&nabla;&fnof;<sub>k</sub>
    вычислить x<sub>k+1</sub> = x<sub>k</sub> + &alpha;<sub>k</sub>p<sub>k</sub>, &alpha;<sub>k</sub> удовлетворяет условиям Вольфе
    обозначить s<sub>k</sub> = x <sub>k+1</sub> - x<sub>k</sub> и y<sub>k</sub> = &nabla;&fnof;<sub>k+1</sub> - &nabla;&fnof;<sub>k</sub>
    вычислить C<sub>k+1</sub>
    k = k+1
end         </pre>
            </blockquote>
            
            <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
                <dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки 
                целостности данных <dfn>md5</dfn> - 128-битный алгоритм хеширования. 
                Предназначен для создания «отпечатков» или дайджестов
                сообщения произвольной длины и последующей проверки их подлинности.</p>
            <p>Потому что он быстрый, компактный и легок в реализации.</p>

            <h5>Итог</h5>

            <p>Фактически мы экономим <strong>80-90% трафика</strong>. Размер загружаемой статитки в байтах:</p>

            <table>
                <thead>
                    <tr>
                        <th>Релиз</th>
                        <th>С патчем</th>
                        <th>Без патча</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>7.7.20</td>
                        <td>397</td>
                        <td>174 549</td>
                    </tr>
                    <tr>
                        <td>7.7.21</td>
                        <td>383</td>
                        <td>53 995</td>
                    </tr>
                    <tr>
                        <td>7.7.22</td>
                        <td>483</td>
                        <td>3 995</td>
                    </tr>
                </tbody>
            </table>

            <div class="author-info">
                    Автор: <a href="http://habrahabr.ru/users/doochik/">@doochik</a>
                    <br>С++ разработчик
                    <br>Электронная почта:
                    <a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>
                    <br>Компания: Яндекс
                    <br>
                </div>

        </main>

        <section>
            <h4>Комментарии (3):</h4>

            <ul class="untagged-list">
                <article>
                    <li>
                        <div class="comment-info">- Mogaika
                            <a href="mailto:mogaika@yandex-team.ru">
                                mogaika@yandex-team.ru</a>
                            <time>30 ноября 2014 в 17:05</time>
                        </div>
                        А можете привести сравнение, на сколько быстрее грузится lite версия?
                    </li>
                </article>

                <article>
                    <li>
                        <div class="comment-info">- JIguse
                            <a href="mailto:mrawesome@yandex.ru">
                                mrawesome@yandex.ru</a>
                            <time>29 ноября 2014 в 21:30</time>
                        </div>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми 
                        подробностями о внутренней работе сервисов.
                    </li>
                </article>

                <article>
                    <li>
                        <div class="comment-info">
                            - Brister
                            <a href="mailto:brist89@yandex-team.ru">brist89@yandex-team.ru</a>
                            <time>24 ноября 2014 в 13:13</time>
                        </div>
                        <blockquote>
                            (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
                        </blockquote>
                        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
                        хорошо или плохо работает почта.
                        <br>
                        <br>наверное все-таки от 0.5 до 1</li>
                </article>

                <article>
                    <li>
                        <div class="comment-info">
                            - alexeimois
                            <a href="mailto:test@yandex.ru">test@yandex.ru</a>
                            <time>22 ноября 2014 в 17:35</time>
                        </div>
                        Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
                        <a href="http://help.yandex.ru/metrika/reports/monitoring_timing.xml">
                            help.yandex.ru/metrika/reports/monitoring_timing.xml</a>
                    </li>
                </article>
            </ul>
        </section>
    </article>

    <footer>
        <address>© Яндекс, help@yandex.ru, Хохрякова, 10</address>
    </footer>

</body>

</html>
