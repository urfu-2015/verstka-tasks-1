<!DOCTYPE html>
<html lang = "ru">
    <head>
    <title>Блог компании Яндекс</title>
    <meta charset = "utf-8">
    <meta name = "keyword" content = "Яндекс, блог">
    <style>
        body {
            font-family: Verdana, sans-serif;
            font-size: 14px;
            }

        thead {
            font-family: Verdana, sans-serif;
            font-size: 14px;
            }

        tbody {
            font-family: Verdana, sans-serif;
            font-size: 14px;
            text-align: center;
            }

        footer {
            text-align: right;
            }
             
        a {
            text-decoration: none;
            }
            
        span {
            color: red;
            }
    </style>

    </head>
    <body>
        дано <var>&#1013</var>, <var>x</var><sub>0</sub><br>
        инициализировать <var>H</var><sub>0</sub><br>
        <var>k</var> = 0<br>
        <strong>while </strong>||&#8711<var>f</var><sub>0</sub>|| > <var>&#1013</var><br>
        <dd>найти направление <var>p</var><sub><var>k</var></sub> = <var>-C<sub>k</sub> &#8711f<sub>k</sub></var></dd>
        <dd>вычислить <var>x<sub>k+1</sub> = x<sub>k</sub> + &#945<sub>k</sub> p<sub>k</sub></var>, <var>&#945<sub>k</sub></var> удовлетворяет условиям Вольфе</dd>
        <dd>обозначить <var>s<sub>k</sub> = x<sub>k+1</sub> - x<sub>k</sub></var> и <var>y<sub>k</sub> = &#8711f<sub>k+1</sub> - &#8711f<sub>k</sub> </var></dd>
        <dd>вычислить <var>C<sub>k+1</sub></var></dd>
        <dd><var>k = k+1</var></dd>
        <strong>end</strong>
        <h2>Блог компании <span>Я</span>ндекс.</h2>

        <h3><span>Я</span>НДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h3>

        <p>
            Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
            какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
            тормозит. Мы регулярно добавляем в <span>Я</span>ндекс.Почту новую функциональность,<br>
            иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
            и новая логика. Всё это напрямую влияет на скорость работы интерфейса.<br>
        </p>

        <h3>Что мы измеряем</h3>        
        <p>Этапы первой загрузки:</p>
        
        <ul>
            <li>подготовка;</li>
            <li>загрузка статики (HTTP-запрос и парсинг);</li>
            <li>сполнение модулей;</li>
            <li>инициализация базовых объектов;</li>
            <li>отрисовка.</li>
        </ul>

        <p>Этапы отрисовки любой страницы:</p>
        <ul>
            <li>подготовка к запросу на сервер;</li>
            <li>запрос данных с сервера;</li>
            <li>шаблонизация;</li>
            <li>обновление DOM.</li>
        </ul>
        — <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы<br>
        — <q>Что же дальше?</q> - вопрошаете вы<br>
        — <q>А давай построим график!</q> - отвечаем мы<br>
        — <q>А что будем считать?</q> - уточняете вы<br>
        <p>
            Как вы знаете, <dfn>медиана</dfn> – это серединное, а не среднее значение в выборке.<br>
            Если у нас имеются числа <var>1, 2, 2, 3, 8, 10, 20,</var>
            то <dfn>медиана</dfn> – <var>3</var>, а <dfn>среднее</dfn> – <var>6,5</var>.<br>
            В общем случае медиана отлично показывает, сколько грузится средний пользователь.
        </p>
        <p>
            В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
            рассказать, сколько пользователей ускорилось, а сколько замедлилось.
        </p>
        <p>
            <abbr title = "Application Performance Index">APDEX</abbr> – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
            работает очень просто. Мы выбираем временной интервал <var>[0; t]</var>, такой, что если<br>
            время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
            интервал, <var>(t; 4t]</var> (в четыре раза больше первого), и считаем, что если страница<br>
            показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
            но уже не настолько счастлив. И применяем формулу:
        </p>
        <p>
            (кол-во счастливых пользователей + кол-во удовлетворенных
            / 2) / (кол-во всех).<br>
            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
            хорошо или плохо работает почта.<br>
        </p>

        <h3>Как мы измеряем</h3>
        <p>
            Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
            причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
            выполняется <code>JavaScript</code>. Выглядит это примерно так:
        </p>
        <p>
            <code>
                this.timings['look-ma-im-start'] = Date.now();<br>
                this.timings['look-ma-finish'] = Date.now();
            </code>
        </p>
        <p>
            C помощью <code>Date.now()</code> мы получаем текущее время.
            Все тайминги собираются и при<br>
            отправке рассчитываются. На этапах разница между <q>end</q> и
             <q>start</q> не считается,<br> а все вычисления производятся в конце:
        </p>
        <p>
            <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
        </p>
        <p>И на сервер прилетают подобные записи:</p>
        <p>
            <code>serverResponse=50&domUpdate=60</code>
        </p>
        <h3>Как мы ускоряем</h3>
        <p>
            Чтобы снизить время загрузки почты при выходе новых версий,<br>
            мы уже делаем следующее:
        </p>
        <ul>
            <li>включаем <abbr title = "сокращение от GNU Zip">gzip</abbr>;</li>
            <li>выставляем заголовки кэширования;</li>
            <li>фризим <abbr title = "Cascading Style Sheets">CSS</abbr>,<abbr title = "JavaScript">JS</abbr>, шаблоны и картинки;</li>
            <li>используем <abbr title = "Content Delivery Network">CDN</abbr>;</li>
        </ul>
        <p>
            Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой<br>
            передавать только diff между ней и той, которая сохранена у пользователя?</q><br>
            В браузере же останется просто наложить патч на клиенте.<br>
        </p>
        <p>
            На самое деле эта идея не нова. Уже существуют стандарты для
            <abbr title = "HyperText Transfer Protocol">HTTP</abbr> — например,<br>
            <abbr title = "Request for Comments">RFC</abbr> 3229 <q>Delta encoding in
            <abbr title = "HyperText Transfer Protocol">HTTP</abbr></q> и
            <q>Google <abbr title = "Secure Digital High Capacity">
            SDHC</abbr></q>, — но по разным причинам они<br>
            не получили должного распространения в браузерах и на серверах.
        </p>
        <p>
            Мы же решили сделать свой аналог на <abbr title = "JavaScript">JS</abbr>.
            Чтобы реализовать этот метод обновления,<br>
            начали искать реализации <code>diff</code> на <abbr title = "JavaScript">JS</abbr>.
            На популярных хостингах кода нашли<br>
            библиотеки:
        </p>
            <ul type = "square">
                <li>VCDiff</li>
                <li>google-diff-patch-match</li>
            </ul>
        <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
    <table>
        <thead>
            <tr>
                <th>Библиотека</th>
                <th>IE 9</th>
                <th> Opera 12</th>
            </tr>
            </thead>
        <tbody>
            <tr>
                <td>vcdiff</td>
                <td>8</td>
                <td>5</td>
            </tr>
            <tr>
                <td>google diff</td>
                <td>1363</td>
                <td>76</td>
            </tr>
        </tbody>
    </table>
    <p>
        После того как мы определились с библиотекой для диффа, нужно определиться с тем,где и как хранить статику на клиенте.
    </p>
    <p>Формат файла с патчами для проекта выглядит так:</p>
    <pre>
        <code>
        [
            {
                "k": "jane.css",
                "p": [patch],
                "s": 4554
            },
            {
                "k": "jane.css",
                "p": [patch],
                "s": 4554
            }
        ]
        </code>
    </pre>
    <p>
        То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У<br>
        каждого объекта есть три свойства. <code>k</code> — названия ключа
        в <code>localStorage</code> для этого<br>
        ресурса. <code>p</code> — патч для ресурса, который сгенерировал <code>vcdiff</code>.
        <code>s</code> — чексумма для<br>
        ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
        наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
    </p>
    <dt><dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dfn></dt>
    <dd>итерационный метод численной оптимизации, предназначенный для<br>
    нахождения локального максимума/минимума нелинейного функционала<br>
    без ограничений.</dd>

    
    <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p>
    <dt><dfn>CRC16/32</dfn></dt> <dd>алгоритм нахождения контрольной суммы,
    предназначенный для проверки целостности данных</dd>
    <dt><dfn>md5</dfn></dt> <dd>128-битный алгоритм хеширования. Предназначен для создания
    <q>отпечатков</q>или дайджестов сообщения произвольной длины и последующей проверки
    их подлинности.</dd>
    
    <p>Потому что он быстрый, компактный и легок в реализации.</p>

    <h3>Итог</h3>
    <p>
        Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:
    </p>
    <table>
        <thead>
            <tr>
                <th>Релиз</th>
                <th>С патчем</th>
                <th>Без патча</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>7.7.20</td>
                <td>397</td>
                <td>174 549</td>
            </tr>
            <tr>
                <td>7.7.21</td>
                <td>383</td>
                <td>53 995</td>
            </tr>
            <tr>
                <td>7.7.22</td>
                <td>483</td>
                <td>3 995</td>
            </tr>
        </tbody>
    </table>

    <p>
        Автор: <code>@doochik</code><br>
        <code>С++</code> разработик<br>
        Электронная почта: (<a href = "mailto:test@yandex.ru">doochik@yandex-team.ru</a>)<br>
        Компания: <span>Я</span>ндекс
    </p>
    <p>Комментарии (3):</p>
    <p>
        - Mogaika (<a href = "mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>)
        <time>30 ноября 2014 в 17:05</time>
    </p>
        <dd>А можете привести сравнение, на сколько быстрее грузится <code>lite</code> версия?</dd>
    <p>
        - JIguse (<a href = "mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>)
        <time>29 ноября 2014 в 21:30</time>
    </p>
        <dd>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
        подробностями о внутренней работе сервисов.</dd>
    <p>
        - Brister (<a href = "mailto:brist89@yandex-team.ru">brist89@yandex-team.ru<a>) 
        <time>24 ноября 2014 в 13:13</time>
    </p>
        <dd>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
        хорошо или плохо работает почта. наверное все-таки от 0.5 до 1</dd>
    
    <p>
        - alexeimois (<a href = "mailto:test@yandex.ru">test@yandex.ru</a>) 
        <time>22 ноября 2014 в 17:35</time>
    </p>
        <dd>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
        <a href = "help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a></dd>
    <footer>
        <address>
            © <span>Я</span>ндекс, <a href = "mailto:help@yandex.ru">help@yandex.ru<a>, Хохрякова, 10
        </address>
    </footer>
  </body>
</html>