<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta name="author" content="doochik">
        <meta name="description" content="Yandex.Mail: How we do measure download speed and improve it">
        <meta name="keywords" content="Yandex, mail, Яндекс, почта, Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно,
        Broyden — Fletcher — Goldfarb — Shanno algorithm">
        <title>Яндекс.Блог</title>
    </head>

    <body>
        <header>
            <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
        </header>

        <article>
            <p>
                Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то, какой он красивый,<br>
                ни то, какой он удобный. Никому не понравится, когда все тормозит. Мы регулярно добавляем в Яндекс.Почту<br>
                новую функциональность, иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код и<br>
                новая логика. Всё это напрямую влияет на скорость работы интерфейса.
            </p>

            <h3>Что мы измеряем</h3>

            <h4>Этапы первой загрузки:</h4>
            <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
            </ul>

            <h4>Этапы отрисовки любой страницы:</h4>
            <ul>
                <li>подготовка к запросу на сервер;</li>
                <li>запрос данных с сервера;</li>
                <li>шаблонизация;</li>
                <li>инициализация базовых объектов;</li>
                <li>обновление DOM.</li>
            </ul>

            <p>
                — <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы<br>
                — <q>Что же дальше?</q> - вопрошаете вы<br>
                — <q>А давай построим график!</q> - отвечаем мы<br>
                — <q>А что будем считать?</q> - уточняете вы
            </p>

            <p>
                Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
                Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
                В общем случае медиана отлично показывает, сколько грузится средний пользователь.
            </p>

            <p>
                В случае ускорения или замедления медиана, конечно, изменится.<br>
                Но она не может рассказать, сколько пользователей ускорилось, а сколько замедлилось.
            </p>

            <p>
                <abbr title="Application Performance Index">APDEX</abbr> – метрика,
                которая сразу говорит: хорошо или плохо.<br>
                Метрика работает очень просто. Мы выбираем временной интервал [0; t], такой,<br>
                что если время показа страницы попало в него, то пользователь счастлив. Берем еще<br>
                один интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
                показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
                но уже не настолько счастлив. И применяем формулу:
            </p>

            <p>
                (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
                Получается значение от нуля до единицы, которое, видимо,<br>
                лучше всего показывает, хорошо или плохо работает почта.
            </p>

            <h3>Как мы измеряем</h3>

            <p>
                Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять причину замедления:<br>
                медленнее стал отвечать сервер либо слишком долго выполняется JavaScript. Выглядит это примерно так:
            </p>

            <p>
                <code>this.timings['look-ma-im-start'] = Date.now();<br>
                this.timings['look-ma-finish'] = Date.now();</code>
            </p>

            <p>
                C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются
                и при отправке рассчитываются.<br>
                На этапах разница между &#8220;end&#8221; и &#8220;start&#8221; не считается, а все
                вычисления производятся в конце:
            </p>

            <pre><code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code></pre>

            <p>И на сервер прилетают подобные записи:</p>

            <p><code>serverResponse=50&domUpdate=60</code><p>

            <h3>Как мы ускоряем</h3>

            <h4>Чтобы снизить время загрузки почты при выходе новых версий, мы уже делаем следующее:</h4>
            <ul>
                <li>включаем <abbr title="GNU Zip">gzip</abbr>;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>
                    фризим <abbr title="Cascading Style Sheets">CSS</abbr>, <abbr title="Java Script">JS</abbr>,
                    шаблоны и картинки;
                </li>
                <li>используем <abbr title="Content Delivery Network">CDN</abbr>;</li>
            </ul>

            <p>
                Мы подумали: &laquo;А что если хранить где-то старую версию файлов, а при выходе
                новой передавать только <code>diff</code><br>
                между ней и той, которая сохранена у пользователя?&raquo; В браузере же
                останется просто наложить патч на клиенте.
            </p>

            <p>
                На самое деле эта идея не нова. Уже существуют стандарты для
                <abbr title="HyperText Transfer Protocol">HTTP</abbr> — например, RFC 3229<br>
                &laquo;Delta encoding in <abbr title="HyperText Transfer Protocol">HTTP</abbr>&raquo;
                и &laquo;Google SDHC&raquo;, — но по разным причинам они не получили<br>
                должного распространения в браузерах и на серверах.
            </p>

            <p>
                Мы же решили сделать свой аналог на <abbr title="Java Script">JS</abbr>.
                Чтобы реализовать этот метод обновления,<br>
                начали искать реализации <code>diff</code> на <abbr title="Java Script">JS</abbr>.
                На популярных хостингах кода нашли библиотеки:
            </p>
            <ul>
                <li>VCDiff</li>
                <li>google-diff-patch-match</li>
            </ul>

            <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>

            <table>
                <thead>
                    <tr>
                        <th>Библиотека</th>
                        <th><abbr title="Internet Explorer">IE</abbr> 9</th>
                        <th>Opera 12</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>vcdiff</td>
                        <td>8</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>google diff</td>
                        <td>1363</td>
                        <td>76</td>
                    </tr>
                </tbody>
            </table>

            <p>
                После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
                где и как хранить стcodeатику на клиенте.
            </p>

            <p>Формат файла с патчами для проекта выглядит так:</p>
                <pre><code>
                    [
                        {
                            "k": "jane.css",
                            "p": [patch],
                            "s": 4554
                        },
                        {
                            "k": "jane.css",
                            "p": [patch],
                            "s": 4554
                        }
                    ]</code></pre>

            <p>
                То есть это обычный массив из объектов. Каждый объект — отдельный ресурс.
                У каждого объекта есть три свойства.<br>
                <dfn>k</dfn> — названия ключа в localStorage для этого ресурса. <dfn>p</dfn> —
                патч для ресурса, который сгенерировал vcdiff.<br>
                <dfn>s</dfn> — чексумма для ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
                наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
            </p>

            <p>
                <dfn>
                    Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно
                    (<abbr title="Broyden — Fletcher — Goldfarb — Shanno algorithm">BFGS</abbr>)
                </dfn>
                    — итерационный метод численной оптимизации,<br>
                    предназначенный для нахождения локального максимума/минимума нелинейного функционала без ограничений.
            </p>

            <h4>Алгоритм:</h4>
            <p>
                Дано <var>&epsilon;</var>, <var>x</var><sub>0</sub><br>
                инициализировать <var>H</var><sub>0</sub><br>
                <var>k</var> = 0<br>
                while ||&nabla;<var>&fnof;</var><sub>k</sub>|| &gt; &epsilon;
                найти направление <var>p</var><sub>k</sub> =
                -<var>C</var><sub>k</sub>&nabla;<var>&fnof;</var><sub>k</sub><br>
                вычислить <var>x</var><sub>k+1</sub> = <var>x</var><sub>k</sub> +
                <var>&alpha;</var><sub>k</sub><var>p</var><sub>k</sub>,
                <var>&alpha;</var><sub>k</sub> удовлетворяет условиям Вольфе<br>
                обозначить <var>s</var><sub>k</sub> = <var>x</var><sub>k+1</sub> -
                <var>x</var><sub>k</sub> и <var>y</var><sub>k</sub> =
                &nabla;<var>&fnof;</var><sub>k+1</sub> - &nabla;<var>&fnof;</var><sub>k</sub><br>
                вычислить <var>C</var><sub>k+1</sub><br>
                <var>k</var> = <var>k</var> + 1<br>
                end
            </p>

            <p>
                Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
                <dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный
                для проверки целостности данных.<br>
                <dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания
                &laquo;отпечатков&raquo; или дайджестов сообщения<br>
                произвольной длины и последующей проверки их подлинности.
            </p>

            <p>Потому что он быстрый, компактный и легок в реализации.</p>

            <h4>Итог</h4>

            <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>

            <table>
                <thead>
                    <tr>
                        <th>Релиз</th>
                        <th>С патчем</th>
                        <th>Без патча</th>
                    </tr>
                </thead>

                <tbody>
                    <tr>
                        <td>7.7.20</td>
                        <td>397</td>
                        <td>174 549</td>
                    </tr>
                    <tr>
                        <td>7.7.21</td>
                        <td>383</td>
                        <td>53 995</td>
                    </tr>
                    <tr>
                        <td>7.7.22</td>
                        <td>483</td>
                        <td>3 995</td>
                    </tr>
                </tbody>
            </table>

            <address>
                Автор: @doochik<br>
                С++ разработик<br>
                Электронная почта: (<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>)<br>
                Компания: Яндекс
            </address>

            <section>
                <h2>Комментарии (3):</h2>

                <article>
                    <p>- Mogaika (<a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>) 30 ноября 2014 в 17:05</p>
                    <p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p>
                </article>

                <article>
                    <p>- JIguse (<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>) 29 ноября 2014 в 21:30</p>
                    <p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
                        подробностями о внутренней работе сервисов.</p>
                </article>

                <article>
                    <p>- Brister (<a href="mailto:brist89@yandex-team.ru">brist89@yandex-team.ru</a>) 24 ноября 2014 в 13:13</p>
                    <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
                        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                        хорошо или плохо работает почта.</p>
                    <p>наверное все-таки от 0.5 до 1</p>
                </article>

                <article>
                    <p>- alexeimois (<a href="mailto:test@yandex.ru">test@yandex.ru</a>) 22 ноября 2014 в 17:35</p>
                    <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
                        <a href="help.yandex.ru/metrika/reports/monitoring_timing.xml">
                            help.yandex.ru/metrika/reports/monitoring_timing.xml</a></p>
                </article>
            </section>
        </article>

        <footer>
            <address>&copy; Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</address>
        </footer>
    </body>
</html>
