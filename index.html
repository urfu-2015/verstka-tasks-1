<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf8">
    <title>Блог компании Яндекс.</title> 
<body>
<style> 
     p {text-indent: 10px; /* Отступ первой строки в пикселах */}
     q {color:red}
</style>
</head>
    <header>
        <h2 style="text-align: center";>
            Блог компании  <q>Я</q>ндекс.
        </h2>
    </header>      
    <h3 style="text-align: center";><q>Я</q>НДЕКС.ПОЧТА:
        КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ
    </h3>
    <hr>  
    <p style="text-align: center">Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
        какой он красивый, ни то, какой он удобный. Никому не понравится, когда все
        тормозит.<br> Мы регулярно добавляем в Яндекс.Почту новую функциональность,
        иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
        и новая логика.<br> Всё это напрямую влияет на скорость работы интерфейса.
    </p> 
    <hr>
    <h3 style="text-align: center";>Что мы измеряем</h3>          
    <h4>Этапы первой загрузки:</h4>
    <ul>
        <li>подготовка;</li>
        <li>загрузка статики (<abbr title=" HyperText Transfer Protocol">HTTP</abbr>-запрос и парсинг);</li>
        <li>исполнение модулей;</li>
        <li>инициализация базовых объектов;</li>
        <li>отрисовка.</li>
    </ul>
    <h4>Этапы отрисовки любой страницы:</h4>
    <ul>
        <li>подготовка к запросу на сервер;</li>
        <li>запрос данных с сервера;</li>
        <li>шаблонизация;</li>
        <li>обновление <abbr title="Document Object Model">DOM</abbr>.</li>
    </ul>
    <p>
        &mdash;" Ок, теперь у нас есть метрики, мы можем отправить их на сервер"&mdash; говорим мы<br>
        &mdash;" Что же дальше? "&mdash; вопрошаете вы<br>
        &mdash;" А давай построим график! "&mdash; отвечаем мы<br>
        &mdash;" А что будем считать? "&mdash; уточняете вы
    </p>
    <p>Как вы знаете, <dfn>медиана</dfn> – это серединное, а не среднее значение в выборке.
        Если у нас имеются<br> числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
        В общем случае медиана отлично показывает,<br> сколько грузится средний пользователь.
        В случае ускорения или замедления медиана, конечно, изменится.<br> Но она не может
        рассказать, сколько пользователей ускорилось, а сколько замедлилось.
    </p>
    <p><abbr title="Application Performance Index">APDEX</abbr> - Метрика, которая сразу говорит: хорошо или плохо. Метрика
        работает очень просто.<br> Мы выбираем временной интервал [0; t], такой, что если
        время показа страницы попало в него,<br> то пользователь счастлив. Берем еще один
        интервал, (t; 4t] (в четыре раза больше первого), и считаем,<br> что если страница
        показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
        но уже не настолько счастлив. И применяем формулу:<br>
        (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
        хорошо или плохо работает почта.
    </p> 
    <h3 style="text-align: center";>Как мы измеряем</h3>    
    <p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
        причину замедления:<br> медленнее стал отвечать сервер либо слишком долго
        выполняется <em>JavaScript</em>. Выглядит это примерно так:
    </p>   
    <p>
        <code>
                    this.timings['look-ma-im-start'] = Date.now();<br>
                    this.timings['look-ma-finish'] = Date.now();<br>
        </code>    
    </p>
    <p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
        отправке рассчитываются.<br> На этапах разница между <em>“end”</em> и <em>“start”</em> не считается,
        а все вычисления производятся в конце:
    </p>
    <p><code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code></p>
    <p>И на сервер прилетают подобные записи:</p>    
    <p><code>serverResponse=50&domUpdate=60</code></p>    
    <h3 style="text-align: center";>Как мы ускоряем</h3>    
    <p>Чтобы снизить время загрузки почты при выходе новых версий,
        мы уже делаем следующее:
    </p>
    <div>
        <ul>
            <li>включаем  <abbr title="сокращение от GNU Zip">gzip</abbr>;</li>
            <li>выставляем заголовки кэширования;</li>
            <li> фризим  <abbr title="Cascading Style Sheets">CSS</abbr>,  <abbr title="JavaScript">JS</abbr>, шаблоны и картинки;</li>
            <li>используем <abbr title="Content Delivery Network">CDN</abbr>;</li>
        </ul>
    </div>
    <p>Мы подумали: А что если хранить где-то старую версию файлов, а при выходе новой
        передавать только<br> <em>diff</em> между ней и той, которая сохранена у пользователя?
        В браузере же останется просто наложить патч на клиенте.
    </p>
    <p>На самое деле эта идея не нова. Уже существуют стандарты для <abbr title=" HyperText Transfer Protocol">HTTP</abbr> — например,
        <em>RFC 3229 «Delta encoding in <abbr title=" HyperText Transfer Protocol">HTTP</abbr></em>»<br> и <em>«Google SDHC»</em>, — но по разным причинам они
        не получили должного распространения в браузерах и на серверах.<br>
        Мы же решили сделать свой аналог на <abbr title="JavaScript">JS</abbr>. Чтобы реализовать этот метод обновления,
        начали искать реализации<br> <em>diff</em> на <abbr title="JavaScript">JS</abbr>. На популярных хостингах кода нашли
        библиотеки:<br>
    </p>   
    <ul>
        <li><em>VCDiff</em></li><br>
        <li><em>google-diff-patch-match</em></li>
    </ul>
    <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
    <div>
        <table width="30%" border="1">
        <tr>
            <th>Библиотека</th>
            <th>IE 9</th>
            <th>Opera 12</th>
        </tr>
        <tr style="text-align: center";>
            <td>vcdiff</td>
            <td>8</td>
            <td>5</td>
        </tr>
        <tr style="text-align: center";>
            <td>google diff</td>
            <td>1363</td>
            <td>76</td>
        </tr>
        </table>
    </div>
    <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
        где и как хранить статику на клиенте.
    </p>  
    <p>Формат файла с патчами для проекта выглядит так:
        <pre><code>
[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]
        </code></pre>
    </p>
    <p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
        каждого объекта есть<br> три свойства. <em>k</em> — названия ключа в <em>localStorage</em> для этого
        ресурса. <em>p</em> — патч для ресурса,<br> который сгенерировал <em>vcdiff. s</em> — чексумма для
        ресурса актуальной версии, чтобы потом можно было<br> проверить правильность
        наложения патча на клиенте. Чексумма вычисляется по <cite>алгоритму Флетчера.</cite>
    </p>
    <p>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (<abbr>BFGS</abbr>)
        — итерационный метод численной оптимизации,<br> предназначенный для
        нахождения локального максимума/минимума нелинейного функционала
        без ограничений.
    </p>
    <br><br>
    <h4>Алгоритм Флетчера</h4>
        <p>Дано &#949;, x<sub>0</sub><br>
            Инициализировать &#919;<sub>0</sub><br>
            &#954;=0<br>
            while||&#8711;&#402;<sub>&#954;</sub>||&#62;&#949;<br>
            Найти направление p<sub>&#954;</sub> = &#8722;&#1017;<sub>&#954;</sub>&#8711;&#402;<sub>&#954;</sub><br>
            Вычислить x<sub>&#954;+1</sub> = x<sub>&#954;</sub> +
            &#945;<sub>&#954;</sub>p<sub>&#954;</sub>,&#945;<sub>&#954;</sub> удовлетворяет условиям                        
            Вольфе<br>
            Обозначить s<sub>&#954;</sub> = x<sub>&#954;+1</sub> &#8722;x<sub>&#954;</sub> и y<sub>&#954;</sub> 
            = &#8711;&#402;<sub>&#954;+1</sub> &#8722; &#8711;&#402;<sub>&#954;</sub><br>
            Вычислить &#1017;<sub>&#954;+1</sub><br>
            &#954; = &#954; + 1<br>
            end
        </p>
        <br><br>
    <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p><br><hr>
    <p><dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки
        целостности данных
    </p><br><hr>
    <p><dfn>md5 - 128</dfn>-битный алгоритм хеширования. Предназначен для создания «отпечатков»
        или дайджестов сообщения<br> произвольной длины и последующей проверки
        их подлинности<hr>.
    </p>
    <p>Потому что он быстрый, компактный и легок в реализации.</p>
    <h3 style="text-align: center";>Итог</h3>
    <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
    <div>
        <table width="30%" border="1">
        <tr>
            <th>Релиз</th>
            <th>С патчем</th>
            <th>Без патча</th>
        </tr>
        <tr style="text-align: center";>
            <td>7.7.20</td>
            <td>397</td>
            <td>174 549</td>
        </tr>
        <tr style="text-align: center";>    
            <td>7.7.21</td>   
            <td>383</td>
            <td>53 995</td>
        </tr>
        <tr style="text-align: center";>
            <td>7.7.22 </td>
            <td>483</td>
            <td>3 995</td>
        </tr>
        </table>
    </div>
    <br><br>  
    <adress>
        <hr>Автор: <em>@doochik</em><br>
        С++ разработик<br>
        Электронная почта: (<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>)<br>
        Компания: Яндекс<br>
    </adress><hr>
    <h4>Комментарии (3):</h4>    
    <h5>-Mogaika</h5> <p>(<a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>) <time>30 ноября 2014 в 17:05</time></p>   
    <p> А можете привести сравнение, на сколько быстрее грузится lite версия?</p>
    <p><h5>-JIguse</h5> <p>(<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>)<time>29 ноября 2014 в 21:30</time></p>
    <p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
        подробностями о внутренней работе сервисов.
    </p>
    <h5>-Brister</h5> <p>(<a href="mailto:brist89@yandex-team.ru">brist89@yandex-team.ru</a>) <time>24 ноября 2014 в 13:13</time></p>   
    <p><math>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).</math><br>
        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
        хорошо или плохо работает почта. 
    </p>   
    <p>наверное все-таки от 0.5 до 1</p>
    <h5>-Alexeimois</h5> <p>(<a href="mailto:test@yandex.ru">test@yandex.ru</a>) <time>22 ноября 2014 в 17:35</time></p>
    <p> Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
    <a href="http://help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a>
    </p>
<footer>    
    <adress>&copy; Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</adress>
</footer>
</body>
</html>
