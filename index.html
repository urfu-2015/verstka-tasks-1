<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="utf-8"/> 
		<title>Блог компании Яндекс</title>
		<!--<meta http-equiv="refresh" content="5">-->
		<base target="_blank"/>
		<style type="text/css"stile="text-align: center" ></style>
	</head>
	<body>
		<header>
			<h1>Блог компании Яндекс.</h1>
		</header>
		<hr />
		<p><b>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</b></p>
		<br />
		<p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br />
			какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br />
			тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br />
			иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br />
			и новая логика. Всё это напрямую влияет на скорость работы интерфейса.<br /> 
			<br>
		<div>
			<b>Что мы измеряем</b>
			<p/>
		<p>Этап первой загрузки:</p>
		<ul>
			<li>подготовка;</li>
			<li>загрузка статики (HTTP-запрос и парсинг);</li>
			<li>исполнение модулей;</li>
			<li>инициализация базовых объектов;</li>
			<li>отрисовка.</li>	
		</ul>
		<p>Этапы отрисовки любой страницы:<p/>
		<ul>
			<li>подготовка к запросу на сервер;</li>
			<li>запрос данных с сервера;</li>
			<li>шаблонизация;</li>
			<li>обновление DOM.</li>
		</ul>
		<p>
			— <q> <i>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</i></q> - говорим мы<br>
			— <q><i>Что же дальше?</i></q> - вопрошаете вы<br>
			— <q><i>А давай построим график!</i></q> - отвечаем мы<br>
			— <q><i>А что будем считать?</i></q> - уточняете вы<br>
		</p>
		<p>
			Как вы знаете, медиана – это серединное, а не среднее значение в выборке.
			Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
			В общем случае медиана отлично показывает, сколько грузится средний пользователь.
		</p>
		<p>
			В случае ускорения или замедления медиана, конечно, изменится. Но она не может
			рассказать, сколько пользователей ускорилось, а сколько замедлилось.
		</p>
		<p>
			<dfn>APDEX</dfn> – метрика, которая сразу говорит: хорошо или плохо.Метрика
			работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
			время показа страницы попало в него, то пользователь счастлив. Берем еще один
			интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
			показана за это время, то пользователь в целом удовлетворен скоростью работы,
			но уже не настолько счастлив. И применяем формулу:
		</p>
		<p>
			<i>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).</i><br>
				Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
				хорошо или плохо работает почта.
		</p>
		</div>
		<div>
		<p>
			<b>Как мы измеряем</b>
		</p>
		<p>
			Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
			причину замедления: медленнее стал отвечать сервер либо слишком долго
			выполняется JavaScript. Выглядит это примерно так:
		</p>
		<pre>
			<code>
	this.timings['look-ma-im-start'] = Date.now();
	this.timings['look-ma-finish'] = Date.now();
			</code>
		</pre>
		<p>
		C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
		отправке рассчитываются. На этапах разница между <code><q>end</q></code> и <code><q>start</q></code> не считается,
		а все вычисления производятся в конце:
		</p>
		<code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
		<p>И на сервер прилетают подобные записи:</p>
		<code>serverResponse=50&domUpdate=60</code>
		</div>
		<div>
		<p>
			<b>Как мы ускоряем</b>
		</p>
		<p>Чтобы снизить время загрузки почты при выходе новых версий,<br>
			мы уже делаем следующее:</p>
		<ul>
			<li>включаем gzip;</li>
			<li>выставляем заголовки кэширования;</li>
			<li>фризим CSS, JS, шаблоны и картинки;</li>
			<li>используем CDN;</li>
		</ul>
		<p>
			Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой
			передавать только <code>diff</code> между ней и той, которая сохранена у пользователя?</q>
			В браузере же останется просто наложить патч на клиенте.
		</p>
		<p>
			На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,
			<code>RFC 3229 <q>Delta encoding in HTTP</q></code> и <code><q>Google SDHC</q></code>, — но по разным причинам они
			не получили должного распространения в браузерах и на серверах.
		</p>
		<p>
			Мы же решили сделать свой аналог на <code>JS</code>. Чтобы реализовать этот метод обновления,
			начали искать реализации <code>diff</code> на <code>JS</code>. На популярных хостингах кода нашли
			библиотеки:
		<pre>
- <code>VCDiff</code>
- <code>google-diff-patch-match</code>
		</pre>
		</p>
		<p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
		<table>
			<thead>
				<tr>
					<td>Библиотека</td>
					<td>IE 9</td>
					<td>Opera 12</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>vcdiff</td>
					<td>8</td>
					<td>5</td>
				</tr>
				<tr>
					<td>google diff</td>
					<td>363</td>
					<td>76</td>
				</tr>
			</tbody>
		</table>
		<p>
			После того как мы определились с библиотекой для диффа, нужно определиться с тем,
			где и как хранить статику на клиенте.
		</p>
		<p>Формат файла с патчами для проекта выглядит так:</p>
		<pre><code>
[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]
		</code></pre>
		<p>
			То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
			каждого объекта есть три свойства. <code>k</code> — названия ключа в <code>localStorage</code> для этого
			ресурса. <code>p</code>— патч для ресурса, который сгенерировал <code>vcdiff</code>. <code>s</code> — чексумма для
			ресурса актуальной версии, чтобы потом можно было проверить правильность
			наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
		</p>
		<p>
			<dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dfn>
				— итерационный метод численной оптимизации, предназначенный для
				нахождения локального максимума/минимума нелинейного функционала
				без ограничений.
		</p>
		<hr />
		<h4>
			Алгоритм Флетчера
		</h4>
		<p>
			дано &expectation; , &xscr; <sub>0</sub> <br>
			Инициализировать H<sub>0</sub><br>
			&kscr;=0<br>
			<pre>
<code><b>while</b></code> || &Del; &fnof;<sub>&kscr;</sub>||&gt; &expectation; <br> 
	найти направление &pscr;<sub>&kscr;</sub>= -&Cscr;<sub>&kscr;</sub>&Del;&fnof;<br>
	вычислить &xscr;<sub>&kscr;+1</sub>=&xscr;<sub>&kscr;</sub>+&alpha;<sub>&kscr;</sub>&pscr;<sub>&kscr;</sub>, &alpha;<sub>&kscr;</sub> удовлетворяет условиям Вольфе<br>
	обозначить &sscr;<sub>&kscr;</sub>=&xscr;<sub>&kscr;+1</sub>-&xscr;<sub>&kscr;</sub> и &yscr;<sub>&kscr;</sub>=&Del;&fnof;<sub>&kscr;+1</sub>-&Del;&fnof;<sub>&kscr;</sub>
	вычислить &Cscr;<sub>&kscr;+1</sub>
	&kscr;=&kscr;+1;
<code><b>end</b></code>
			</pre>
		</p>
		<hr />
		<P>
			Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
			<ul>
			<li><dfn>CRC16/32</dfn>- алгоритм нахождения контрольной суммы, предназначенный для проверки
			целостности данных</li>
			<li><dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
			или дайджестов сообщения произвольной длины и последующей проверки
			их подлинности.</li>
			</ul>
		</P>
		<p><i>Потому что он быстрый, компактный и легок в реализации.</i></p>
		</div>
		<p><b>Итог</b></p>
		<p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
		<table>
			<thead>
				<tr>
				 	<td>Релиз</td>
				 	<td>С патчем</td>
				 	<td>Без патча</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>7.7.20 </td>
					<td>397</td> 
					<td>174 549</td>
				</tr>
				<tr>
					<td>7.7.21</td>
					<td>383</td>
					<td>53 995</td>
				</tr>
				<tr>
					<td>7.7.22</td>
					<td>483</td>
					<td>3 995</td>
				</tr>
			</tbody>
		</table>
		<!--<footer>-->
			<p>
				<pre>
Автор: @doochik
С++ разработик
Электронная почта: (<a href="https://doochik@yandex-team.ru">doochik@yandex-team.ru</a>)
Компания: Яндекс
				</pre>
			</p>
			<section>
				<h1>Комментарии (3):</h1>
				<article>
					- Mogaika (<a href="https://mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>) <Date> 30 ноября 2014 в 17:05</Date>

  					<p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p>
  				</article>
  				<article>

					- JIguse (<a href="https://mrawesome@yandex.ru">mrawesome@yandex.ru</a>) <Date> 29 ноября 2014 в 21:30</Date>

  					<p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
  						подробностями о внутренней работе сервисов.</p>
  				</article>
  				<article>

					- Brister (<a href="https://brist89@yandex-team.ru">brist89@yandex-team.ru</a>) <Date> 24 ноября 2014 в 13:13</Date>

  					<p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
  					Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
  					хорошо или плохо работает почта.</p>

 					 <p>наверное все-таки от 0.5 до 1</p>
  				</article>
  				<article>

					- alexeimois (<a href="https://test@yandex.ru">test@yandex.ru</a>) <Date> 22 ноября 2014 в 17:35</Date>

  					<p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:</p>
  					<a href="https://help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a>
  				</article>
  			</section>
  			<br>
  		<footer>
  			<pre>	
© Яндекс, <a href="https://help@yandex.ru">help@yandex.ru</a>, <address>Хохрякова, 10</address> 
			</pre>	
		</footer>
	</body>

</html>