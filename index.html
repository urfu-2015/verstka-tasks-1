<html>
<head>
	<meta charset="UTF-8">
	<meta name="andrej.veshinin" content="Domashka1">
	<title>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</title>
</head>
<body>
<header>
	<nav>
		<a href="#Что мы измеряем">Что мы измеряем</a>
		<a href="#Как мы измеряем">Как мы измеряем</a>
		<a href="#Как мы ускоряем">Как мы ускоряем</a>
		<a href="#Алгоритм Бройдена Флетчера(BFGS">Алгоритм Бройдена Флетчера(BFGS)</a>
		<a href="#Коментарии">Коментарии</a>
	</nav>		 
<h2>Яндекс.почта: как мы измеряем скорость загрузки и улучшаем её<h2> 
</header>
<p>
	Если ваш сайт медленно грузится,
	вы рискуете тем, что люди не оценят ни то,
	какой он красивый, ни то, какой он удобный.<br>
	Никому не понравится, когда все тормозит. 
	Мы регулярно добавляем в Яндекс.
	Почту новую функциональность,<br> иногда — исправляем ошибки, 
	а это значит, у нас постоянно появляются новый код
	и новая логика.<br> Всё это напрямую влияет на скорость работы интерфейса.
</p>
<hr>
<a name="Что мы измеряем"><h2><u>Что мы измеряем</u></h2></a> <!-- Чтоы слово было подчеркнуто. Элемент U."-->
<h3>Этапы первой загрузки:</h3>
<ul>
	<li>Подготовка;</li>
	<li>загрузка статики (HTTP-запрос и парсинг);</li>
	<li>исполнение модулей;</li>
	<li>инициализация базовых объектов;</li>
	<li>Отрисовка.</li>
</ul>

<article>
	<h2>Этапы отрисовки любой страницы:</h2>
	<ul>
		<li>подготовка к запросу на сервер;</li>
		<li>запрос данных с сервера;</li>
		<li>шаблонизация;</li>
		<li>обновление DOM.</li>
	</ul>
	<p>
	-«Ок, теперь у нас есть метрики, мы можем отправить их на сервер»<br> - говорим мы
	— «Что же дальше?» - вопрошаете вы
	— «А давай построим график!» - отвечаем мы
	— «А что будем считать?» - уточняете вы		 
		</p>
	<p>
		Как вы знаете,<mark> медиана – это серединное
	</mark>, а не среднее значение в выборке.
		Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
		В общем случае медиана отлично показывает, сколько грузится средний пользователь.
		В случае ускорения или замедления медиана, конечно, изменится. Но она не может
		рассказать, сколько пользователей ускорилось, а сколько замедлилось.
		APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика
		работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
		время показа страницы попало в него, то пользователь счастлив. Берем еще один
		интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
		показана за это время, то пользователь в целом удовлетворен скоростью работы,
		но уже не настолько счастлив. И применяем формулу:
		<mark>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех)</mark>.
		Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
		хорошо или плохо работает почта.</p>

	<a name="Как мы измеряем"><h1>Как мы измеряем</h1></a>
	<h2>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
		причину замедления: медленнее стал отвечать сервер либо слишком долго
		выполняется JavaScript.</h2>
	<figure>
		<figcaption>Выглядит это примерно так:</figcaption>
		<pre><code>
		this.timings['look-ma-im-start'] = Date.now();
		this.timings['look-ma-finish'] = Date.now();
		</code></pre>
	</figure>
	<p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
отправке рассчитываются. </p>
	<figure>
		<figcaption>На этапах разница между “end” и “start” не считается,
			а все вычисления производятся в конце:</figcaption>
		<pre><code>
	var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
		</code></pre>
		<figcaption>И на сервер прилетают подобные записи:</figcaption>
		<pre><samp>serverResponse=50&domUpdate=60</samp>></pre>
	</figure>
	<hr>
	<h2><a name="Как мы ускоряем">Как мы ускоряем</a></h2>
	<h3>Чтобы снизить время загрузки почты при выходе новых версий,
			мы уже делаем следующее:</h3>
	<ul>
		<li>включаем gzip;</li>
		<li>выставляем заголовки кэширования;</li>
		<li>фризим CSS, JS, шаблоны и картинки;</li>
		<li>используем CDN;</li>
	</ul>
	<p>Мы подумали: <q>«А что если хранить где-то старую версию файлов, а при выходе новой
		передавать только <mark>diff</mark> между ней и той, которая сохранена у пользователя?»</q>
		В браузере же останется просто наложить патч на клиенте.
		На самое деле эта идея не новая.<br> Уже существуют стандарты для HTTP — например,
		RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
		не получили должного распространения в браузерах и на серверах.
		Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,
		начали искать реализации diff на JS. На популярных хостингах кода нашли
		библиотеки:</p>
	<ul>
		<li>VCDiff;</li>
		<li>google-diff-patch-match.</li>
	</ul>
	<h4>Для окончательного выбора библиотеки нам нужно сравнить:</h4>
	<table border="1" bgcolor="white" height="100" width="250">
		<thead>
		<tr>
			<th>Библиотека</th>
			<th>IE 9 </th>
			<th>Opera 12</th>
		</tr>
		</thead>
		<tbody>
		<tr>
			<td>vcdiff</td>
			<td>8</td>
			<td>5</td>
		</tr>
		<tr>
			<td>google diff</td>
			<td>1363</td>
			<td>76</td>		
		</tr>
		</tbody>
	</table>
	<h5>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
	где и как хранить статику на клиенте.</h5>
	<figure>
		<figcaption>Формат файла с патчами для проекта выглядит так:</figcaption>
		<pre><code>
			{
			"k": "jane.css",
			"p": [patch],
			"s": 4554
			},
			{
			"k": "jane.css",
			"p": [patch],
			"s": 4554
			}
		</code></pre>
	</figure>
	<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
		каждого объекта есть три свойства: <blockquote>k — названия ключа в <code>localStorage</code>
		для этого ресурса.</blockquote> <blockquote>p — патч для ресурса, который сгенерировал vcdiff.
		</blockquote> <blockquote>s — чексумма для ресурса актуальной версии, чтобы потом можно было проверить
		правильность наложения патча на клиенте.</blockquote>
	<h5>Чексуммавычисляется по алгоритму Флетчера.</h5>
	<a name="Алгоритм Бройдена Флетчера(BFGS"><dl>
		<dt>Алгоритм Бройдена Флетчера(BFGS)</dt>
		<dd>итерационный метод численной оптимизации, предназначенный для
			нахождения локального максимума/минимума нелинейного функционала
			без ограничений.
		</dd>
	</dl></a>
	<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p>
	<dl>
		<dt>CRC16/32 -</dt>
		<dd>алгоритм нахождения контрольной суммы, предназначенный для проверкицелостности данных.</dd>
		<dt>md5 -</dt>
		<dd>128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
			или дайджестов сообщения произвольной длины и последующей проверки
			их подлинности.</dd>
	</dl>
	<h5>Потому что он быстрый, компактный и легок в реализации!!!</h5>
	<hr>
	<hgroup>
		<h5>Итог.</h5>
		<h6>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</h6>
	</hgroup>
	<table>
		<thead>
		<tr>
			<th>Релиз</th>
			<th>С патчем</th>
			<th>Без патча</th>
		</tr>
		</thead>
		<tr>
			<td>7.7.20</td>
			<td>397</td>
			<td>174 549</td>
		</tr>
		<tr>
			<td>7.7.21</td>
			<td>383</td>
			<td>53 995</td>
		</tr>
		<tr>
			<td>7.7.22</td>
			<td>483</td>
			<td>3 995</td>
		</tr>
	</table>
	<hr>
	<footer>
		<p>Автор: <strong>@doochik</strong>С++ разработчик
		<address>Электронная почта:<a href="mailto:doochik@yandex-team.ru"> (doochik@yandex-team.ru)</a></address>
		</p>
		<p>Компания: Яндекс</p>
	</footer>
	<a name="Коментарии"><p>Коментарии(3):</p></a>
	<section>
		<article>
			- Mogaika <a href="mailto:mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a>30 ноября 2014 в 17:05
			А можете привести сравнение, на сколько быстрее грузится lite версия?
		</article>
		<article>
			- JIguse <a href="mailto:mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> 29 ноября 2014 в 21:30
			Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
			подробностями о внутренней работе сервисов.
		</article>
		<article>
			- Brister <a href="mailto:brist89@yandex-team.ru">(brist89@yandex-team.ru)</a> 24 ноября 2014 в 13:13
			(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
			 Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
			хорошо или плохо работает почта.наверное все-таки от 0.5 до 1
		</article>
		<article>
			- alexeimois <a href="mailto:test@yandex.ru">(test@yandex.ru)</a> 22 ноября 2014 в 17:35
	 		Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
	 		help.yandex.ru/metrika/reports/monitoring_timing.xml
		</article>
	</section>
	<hr>
	<footer>
		<p>© Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</p>
	</footer>
</body>
</html>